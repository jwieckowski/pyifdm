Usage example of different multi-criteria techniques implemented in the library is presented.

Imports
-------

.. code-block:: python
   :linenos:

    import numpy as np
    from tabulate import tabulate

    from pyifdm import methods
    from pyifdm.methods import ifs
    from pyifdm import weights as ifs_weights
    from pyifdm import correlations as corrs
    from pyifdm.helpers import rank, generate_ifs_matrix

    import warnings

    warnings.filterwarnings('ignore')
    np.set_printoptions(suppress=True, precision=3)

Input data
------------

To enable multi-criteria evaluation, the decision matrix needs to be defined. It can be determined based on the real data, or random data generated by the method provided in the library.

.. code-block:: python
   :linenos:

    # real data matrix
    matrix = np.array([
        [[0.4745, 0.5255], [0.4752, 0.5248], [0.2981, 0.7019], [0.4374, 0.5627]],
        [[0.5346, 0.4654], [0.5532, 0.4468], [0.6300, 0.3700], [0.5901, 0.4099]],
        [[0.4324, 0.5676], [0.4030, 0.5970], [0.4298, 0.5702], [0.4361, 0.5639]],
        [[0.5235, 0.4765], [0.4808, 0.5192], [0.5667, 0.4333], [0.2913, 0.7087]],
        [[0.4168, 0.5832], [0.4923, 0.5077], [0.4732, 0.5268], [0.4477, 0.5523]]
    ])

    # randomly generated matrix
    # 5 alternatives
    # 4 criteria
    random_matrix = generate_ifs_matrix(5, 4)
    print(random_matrix)

Normalization
--------------

Data normalization converts the range of values that they are placed in range between 0 and 1. Below the usage examples of methods implemented in the library is presented. Types parameter are responsible for the direction of the normalization. One columns' values could be more preferred is the values are lower (`-1` - cost), while others could be more preferred if the values are greater (`1` - profit).

.. code-block:: python
   :linenos:

    normalizations = {
        'Ecer normalization': ifs.normalization.ecer_normalization,
        'minmax_normalization': ifs.normalization.minmax_normalization,
        'Supriya normalization': ifs.normalization.supriya_normalization,
        'Swap normalization': ifs.normalization.swap_normalization,
    }


    types = np.array([1, -1, 1, -1])

    for name, norm in normalizations.items():
        nmatrix = norm(matrix, types)
        print(f'{name}\n\n {nmatrix[:2]}\n')

Distance measures
-----------------

Distance measures allow to indicate how different are given two fuzzy numbers. Different techniques have been developed to this end. The measures for the IFS implemented in the library and their usage are presented below.

.. code-block:: python
   :linenos:
   
    distances = {
        'Euclidean' : ifs.distance.euclidean_distance,
        'Grzegorzewski': ifs.distance.grzegorzewski_distance,
        'Hamming': ifs.distance.hamming_distance,
        'Luo distance': ifs.distance.luo_distance,
        'Normalized Hamming': ifs.distance.normalized_hamming_distance,
        'Normalized Euclidean': ifs.distance.normalized_euclidean_distance,
        'Wang Xin 1': ifs.distance.wang_xin_distance_1,
        'Wang Xin 2': ifs.distance.wang_xin_distance_2,
        'Yang Chiclana': ifs.distance.yang_chiclana_distance,
    }

    x = np.array([0.7, 0.3])
    y = np.array([0.45, 0.5])

    for name, distance in distances.items():
        if distance.__name__ == 'normalized_euclidean_distance':
            d = np.sqrt(1/2 * distance(x, y))
        elif distance.__name__ == 'normalized_hamming_distance':
            d = 1/2 * distance(x, y)
        else:
            d = distance(x, y)
        print(f'{name}: {d}')

Score functions
----------------

To create a crisp ranking from the calculations performed in fuzzy environment, the score functions should be used. Different techniques can be applied to achieve this. The implemented methods and the example of their usage are presented below.

.. code-block:: python
   :linenos:
   
    score_functions = {
        'Chen score 1': ifs.score.chen_score_1,                                                                                          
        'Chen score 2': ifs.score.chen_score_2,                                                                                          
        'Kharal score 1': ifs.score.kharal_score_1,                                                                                          
        'Kharal score 2': ifs.score.kharal_score_2,                                                                                          
        'Liu Wang score': ifs.score.liu_wang_score,                                                                                          
        'Supriya score': ifs.score.supriya_score,                                                                                          
        'Thakur score': ifs.score.thakur_score,                                                                                          
        'Wan Dong score 1': ifs.score.wan_dong_score_1,                                                                                          
        'Wan Dong score 2': ifs.score.wan_dong_score_2,                                                                                          
        'Wei score': ifs.score.wei_score,                                                                                          
        'Zhang Xu score 1': ifs.score.zhang_xu_score_1,                                                                                          
        'Zhang Xu score 2': ifs.score.zhang_xu_score_2,                                                                                          
    }

    x = np.array([0.8, 0.15])

    for name, score in score_functions.items():
        d = score(x)
        print(f'{name}: {d}')


Weights
---------

Criteria weights in multi-criteria problems are responsible for the importance of each parameter taken into consideration. The greater value assigned to the given criterion, the more important it will be in the assessment. For the purpose of weights definition, different methods from the library can be used. They are based on the statistical approach, which makes it possible to define the weights objectively, relying only on data diversity.

.. code-block:: python
   :linenos:

    weights_methods = {
        'Burillo Entropy': ifs_weights.burillo_entropy_weights,
        'Equal': ifs_weights.equal_weights,
        'Entropy': ifs_weights.entropy_weights,
        'Liu Entropy': ifs_weights.liu_entropy_weights,
        'Szmidt Entropy': ifs_weights.szmidt_entropy_weights,
        'Thakur Entropy': ifs_weights.thakur_entropy_weights,
        'Ye Entropy': ifs_weights.ye_entropy_weights,
    }

    for name, method in weights_methods.items():
        w = method(matrix)
        print(f'{name} \n {w}\n')


Evaluation 
-----------

Different techniques from the group of Fuzzy Multi-Criteria Decision Analysis methods based on the Intuitionistic Fuzzy Sets can be used to assess the alternatives. The library includes 9 methods which can be used for this purpose. The examples of their application are presented below.

Decision matrix
----------------

Decision matrix represents the alternatives taken into consideration in the problem. Rows represent amount of alternatives, when columns describes the amount of criteria in the given problem. In the case presented below, we have 5 alternatives and 4 criteria. Moreover, all elements in the matrix should be represented as the Intuitionistic Fuzzy Sets. Both representation with 2 or 3 elements in a fuzzy set are allowed.

.. code-block:: python
   :linenos:

    matrix = np.array([
        [[0.4745, 0.5255], [0.4752, 0.5248], [0.2981, 0.7019], [0.4374, 0.5627]],
        [[0.5346, 0.4654], [0.5532, 0.4468], [0.6300, 0.3700], [0.5901, 0.4099]],
        [[0.4324, 0.5676], [0.4030, 0.5970], [0.4298, 0.5702], [0.4361, 0.5639]],
        [[0.5235, 0.4765], [0.4808, 0.5192], [0.5667, 0.4333], [0.2913, 0.7087]],
        [[0.4168, 0.5832], [0.4923, 0.5077], [0.4732, 0.5268], [0.4477, 0.5523]]
    ])


Weights
---------

Weights can be defined objectively, as shown above with the given examples. However, the weights can be also defined directly based on expert knowledge. The library is implemented in a way to handle both crisp and fuzzy weights. Amount of weights should equal the criteria amount. They can be determined as follow.

.. code-block:: python
   :linenos:

   crisp_weights = np.array([0.2, 0.3, 0.15, 0.35])
   fuzzy_weights = np.array([[0.6, 0.35], [0.8, 0.2], [0.5, 0.45], [0.2, 0.7]])


Criteria
---------

Criteria types are used to reflect the direction of the values that is preferable in the problem. If the values for given criterion should be as big as possible, it is then a profit type and represent as `1` in the criteria types array. If the values should be as low as possible, it is then cost and should be represent as `-1` in the array. Moreover, the criteria types amount should equal amount of criteria in the decision matrix.

.. code-block:: python
   :linenos:

   types = np.array([1, -1, 1, -1])

   
IF-ARAS
-----------

.. code-block:: python
   :linenos:

   if_aras = methods.ifARAS()

IF-ARAS evaluation results with crisp and fuzzy weights  

.. code-block:: python
   :linenos:

   print(f'Crisp weights: {if_aras(matrix, crisp_weights, types)}')
   print(f'Fuzzy weights: {if_aras(matrix, fuzzy_weights, types)}')

The ARAS method can be used with different normalizations. Default, it is a `swap_normalization`.

.. code-block:: python
   :linenos:

    aras = {
        'Ecer normalization': methods.ifARAS(normalization=ifs.normalization.ecer_normalization),
        'Minmax normalization': methods.ifARAS(normalization=ifs.normalization.minmax_normalization),
        'Supriya normalization': methods.ifARAS(normalization=ifs.normalization.supriya_normalization),
        'Swap normalization': methods.ifARAS(normalization=ifs.normalization.swap_normalization),
    }

For every normalization technique, the assessment can be performed to obtain results and check if the type of normalization impacts the outcome.

.. code-block:: python
   :linenos:

    results = {}
    for name, function in aras.items():
        results[name] = function(matrix, fuzzy_weights, types)

    print(tabulate([[name, *np.round(pref, 2)] for name, pref in results.items()],
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))

It can be seen that different preferences are obtained with different normalizations. To check if the alternatives are ranked at the same place despite used normalization method, we can use the method from the library called `rank` which calculates ascending or descending position order based on given array. Since the IF-ARAS method assess better alternatives with higher values, the order should be descending. 

.. code-block:: python
   :linenos:

    print(tabulate([[name, *rank(pref, descending=True)] for name, pref in results.items()], 
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))

It can be seen, that the ranking of alternatives is different for different normalization techniques. So the user should bear in mind that different methods can have impact the final result obtained within selected evaluation method.

IF-CODAS
-----------

.. code-block:: python
   :linenos:

   if_codas = methods.ifCODAS()
   print(if_codas(matrix, fuzzy_weights, types)) 

Within the CODAS method we can also use different normalizations, as it was in the ARAS method. In addition, we can use different distance metrics to calculate the alternatives preference. Default the `distance_1` is the `euclidean_distance` and `distance_2` is the `hamming_distance`. While calling the fuzzy CODAS object, the `tau` parameter can be given, which is set to `0.05` as default. It is treated as the threshold parameter while calculating the relative assessment matrix. CODAS also assessed better alternatives with higher preferences.

.. code-block:: python
   :linenos:

    codas = {
        'Pair 1': methods.ifCODAS(distance_1=ifs.distance.euclidean_distance, distance_2=ifs.distance.hamming_distance),
        'Pair 2': methods.ifCODAS(distance_1=ifs.distance.normalized_euclidean_distance, distance_2=ifs.distance.normalized_hamming_distance),
        'Pair 3': methods.ifCODAS(distance_1=ifs.distance.wang_xin_distance_1, distance_2=ifs.distance.wang_xin_distance_2),
    }

Now, when the CODAS object with different pairs of distances is defined, the results can be calculated.

.. code-block:: python
   :linenos:

    results = {}
    for name, function in codas.items():
        results[name] = function(matrix, fuzzy_weights, types)
    
    print(tabulate([[name, *np.round(pref, 2)] for name, pref in results.items()],
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))

It can be seen, that different distance metrics also have impact on the final results.

IF-COPRAS
-----------

.. code-block:: python
   :linenos:

   if_copras = methods.ifCOPRAS()
   print(if_copras(matrix, fuzzy_weights, types))

In the COPRAS technique, the used score function can be modified. The `thakur_score` is set as default. Similarly to previous methods, better alternatives are assessed with higher preferences.

.. code-block:: python
   :linenos:

    copras = {
        'Chen score 1': methods.ifCOPRAS(score=ifs.score.chen_score_1),                                                                                          
        'Chen score 2': methods.ifCOPRAS(score=ifs.score.chen_score_2),                                                                                          
        'Kharal score 1': methods.ifCOPRAS(score=ifs.score.kharal_score_1),                                                                                          
        'Kharal score 2': methods.ifCOPRAS(score=ifs.score.kharal_score_2),                                                                                          
        'Liu Wang score': methods.ifCOPRAS(score=ifs.score.liu_wang_score),                                                                                          
        'Supriya score': methods.ifCOPRAS(score=ifs.score.supriya_score),                                                                                          
        'Thakur score': methods.ifCOPRAS(score=ifs.score.thakur_score),                                                                                          
        'Wan Dong score 1': methods.ifCOPRAS(score=ifs.score.wan_dong_score_1),                                                                                          
        'Wan Dong score 2': methods.ifCOPRAS(score=ifs.score.wan_dong_score_2),                                                                                          
        'Wei score': methods.ifCOPRAS(score=ifs.score.wei_score),                                                                                          
        'Zhang Xu score 1': methods.ifCOPRAS(score=ifs.score.zhang_xu_score_1),                                                                                          
        'Zhang Xu score 2': methods.ifCOPRAS(score=ifs.score.zhang_xu_score_2),
    }

    results = {}
    for name, function in copras.items():
        results[name] = function(matrix, fuzzy_weights, types)

    print(tabulate([[name, *np.round(pref, 2)] for name, pref in results.items()],
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))

IF-EDAS
-----------

.. code-block:: python
   :linenos:

   if_edas = methods.ifEDAS()
   print(if_edas(matrix, crisp_weights, types))

In case of using the IF-EDAS method, the normalization function and score function can be changed. EDAS also evaluate better alternatives with higher preferences.

.. code-block:: python
   :linenos:

    edas = {
        'Ecer normalization': methods.ifEDAS(normalization=ifs.normalization.ecer_normalization),
        'Minmax normalization': methods.ifEDAS(normalization=ifs.normalization.minmax_normalization),
        'Supriya normalization': methods.ifEDAS(normalization=ifs.normalization.supriya_normalization),
        'Swap normalization': methods.ifEDAS(normalization=ifs.normalization.swap_normalization),
    }

After IF-EDAS object definition, the results based on using different normalizations can be calculated.

.. code-block:: python
   :linenos:

    results = {}
    for name, function in edas.items():
        results[name] = function(matrix, crisp_weights, types)

    print(tabulate([[name, *np.round(pref, 2)] for name, pref in results.items()],
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))

It can be noticed that the results are highly similar while using different normalization methods.

IF-MABAC
-----------

.. code-block:: python
   :linenos:

   if_mabac = methods.ifMABAC()
   print(if_mabac(matrix, fuzzy_weights, types))

While using the IF-MABAC method, the normalization, distance, score function and adjust parameters can be modified. MABAC classify better alternatives with higher preferences.

.. code-block:: python
   :linenos:

    mabac = {
        'Euclidean' : methods.ifMABAC(distance=ifs.distance.euclidean_distance),
        'Grzegorzewski': methods.ifMABAC(distance=ifs.distance.grzegorzewski_distance),
        'Hamming': methods.ifMABAC(distance=ifs.distance.hamming_distance),
        'Luo distance': methods.ifMABAC(distance=ifs.distance.luo_distance),
        'Normalized Euclidean': methods.ifMABAC(distance=ifs.distance.normalized_euclidean_distance),
        'Normalized Hamming': methods.ifMABAC(distance=ifs.distance.normalized_hamming_distance),
        'Wang Xin 1': methods.ifMABAC(distance=ifs.distance.wang_xin_distance_1),
        'Wang Xin 2': methods.ifMABAC(distance=ifs.distance.wang_xin_distance_2),
        'Yang Chiclana': methods.ifMABAC(distance=ifs.distance.yang_chiclana_distance),
    }

    results = {}
    for name, function in mabac.items():
        results[name] = function(matrix, fuzzy_weights, types)

    print(tabulate([[name, *np.round(pref, 2)] for name, pref in results.items()],
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))

Again it can seen, that different distances measure used in the assessment have impact on the final result from the IF-MABAC method.

IF-MAIRCA
-----------

.. code-block:: python
   :linenos:

   if_mairca = methods.ifMAIRCA()
   print(if_mairca(matrix, crisp_weights, types))

IF-MAIRCA method allows for adjusting the parameters responsible for the normalization and the distance measures. Default settings covers the `minmax_normalization` and the `normalized_euclidean_distance`. MAIRCA assigns higher preference values to better classified alternatives.

.. code-block:: python
   :linenos:

    mairca = {
        'Euclidean' : methods.ifMAIRCA(distance=ifs.distance.euclidean_distance),
        'Grzegorzewski': methods.ifMAIRCA(distance=ifs.distance.grzegorzewski_distance),
        'Hamming': methods.ifMAIRCA(distance=ifs.distance.hamming_distance),
        'Luo distance': methods.ifMAIRCA(distance=ifs.distance.luo_distance),
        'Normalized Euclidean': methods.ifMAIRCA(distance=ifs.distance.normalized_euclidean_distance),
        'Normalized Hamming': methods.ifMAIRCA(distance=ifs.distance.normalized_hamming_distance),
        'Wang Xin 1': methods.ifMAIRCA(distance=ifs.distance.wang_xin_distance_1),
        'Wang Xin 2': methods.ifMAIRCA(distance=ifs.distance.wang_xin_distance_2),
        'Yang Chiclana': methods.ifMAIRCA(distance=ifs.distance.yang_chiclana_distance),
    }

    results = {}
    for name, function in mairca.items():
        results[name] = function(matrix, fuzzy_weights, types)

    print(tabulate([[name, *np.round(pref, 2)] for name, pref in results.items()],
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))

It can be seen, that using different distances in this particular case did not cause any changes in the assessments, which shows high robustness of the results.

IF-MOORA
-----------

.. code-block:: python
   :linenos:

   if_moora = methods.ifMOORA()
   print(if_moora(matrix, fuzzy_weights, types))

IF-MOORA assigns higher preferences to better alternatives. It allows for the modification of the score function, and the default method is set to `zhang_xu_score_2`.

.. code-block:: python
   :linenos:

    moora = {
        'Chen score 1': methods.ifMOORA(score=ifs.score.chen_score_1),                                                                                          
        'Chen score 2': methods.ifMOORA(score=ifs.score.chen_score_2),                                                                                          
        'Kharal score 1': methods.ifMOORA(score=ifs.score.kharal_score_1),                                                                                          
        'Kharal score 2': methods.ifMOORA(score=ifs.score.kharal_score_2),                                                                                          
        'Liu Wang score': methods.ifMOORA(score=ifs.score.liu_wang_score),                                                                                          
        'Supriya score': methods.ifMOORA(score=ifs.score.supriya_score),                                                                                          
        'Thakur score': methods.ifMOORA(score=ifs.score.thakur_score),                                                                                          
        'Wan Dong score 1': methods.ifMOORA(score=ifs.score.wan_dong_score_1),                                                                                          
        'Wan Dong score 2': methods.ifMOORA(score=ifs.score.wan_dong_score_2),                                                                                          
        'Wei score': methods.ifMOORA(score=ifs.score.wei_score),                                                                                          
        'Zhang Xu score 1': methods.ifMOORA(score=ifs.score.zhang_xu_score_1),                                                                                          
        'Zhang Xu score 2': methods.ifMOORA(score=ifs.score.zhang_xu_score_2),
    }

    results = {}
    for name, function in moora.items():
        results[name] = function(matrix, fuzzy_weights, types)

    print(tabulate([[name, *np.round(pref, 2)] for name, pref in results.items()],
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))

IF-TOPSIS
-----------

.. code-block:: python
   :linenos:

   if_topsis = methods.ifTOPSIS()
   print(if_topsis(matrix, crisp_weights, types))

IF-TOPSIS technique allows for adjusting the parameters responsible the distance calculation. Default distance is set to `normalized_euclidean_distance`. TOPSIS assures, that better alternatives have higher preferences values. 

.. code-block:: python
   :linenos:

    topsis = {
        'Euclidean' : methods.ifTOPSIS(distance=ifs.distance.euclidean_distance),
        'Grzegorzewski': methods.ifTOPSIS(distance=ifs.distance.grzegorzewski_distance),
        'Hamming': methods.ifTOPSIS(distance=ifs.distance.hamming_distance),
        'Luo distance': methods.ifTOPSIS(distance=ifs.distance.luo_distance),
        'Normalized Hamming': methods.ifTOPSIS(distance=ifs.distance.normalized_hamming_distance),
        'Normalized Euclidean': methods.ifTOPSIS(distance=ifs.distance.normalized_euclidean_distance),
        'Wang Xin 1': methods.ifTOPSIS(distance=ifs.distance.wang_xin_distance_1),
        'Wang Xin 2': methods.ifTOPSIS(distance=ifs.distance.wang_xin_distance_2),
        'Yang Chiclana': methods.ifTOPSIS(distance=ifs.distance.yang_chiclana_distance),
    }

    results = {}
    for name, function in topsis.items():
        results[name] = function(matrix, fuzzy_weights, types)

    print(tabulate([[name, *np.round(pref, 2)] for name, pref in results.items()],
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))


IF-VIKOR
-----------

.. code-block:: python
   :linenos:

    if_vikor = methods.ifVIKOR()
    res = if_vikor(matrix, fuzzy_weights, types)
    print(f'S: {res[0]}')
    print(f'R: {res[1]}')
    print(f'Q: {res[2]}')

VIKOR method is characterized by returning three assessment vectors (S, R, Q). The difference between them lays in the way how they are calculated in the final phase of the evaluation. The VIKOR method performance can be adjusted with the distance method, which by default is set to `hamming_distance`. Moreover, while creating the IF-VIKOR object, the `v` parameter can be given, which translates how the weight of the strategy will behave. It is set to `0.5` as default. VIKOR ranking can be calculated by sorting the preferences in the ascending order, so in the `rank` method, the parameter should be sey as `descending=False`.

.. code-block:: python
   :linenos:

    vikor = {
        'Euclidean' : methods.ifVIKOR(distance=ifs.distance.euclidean_distance),
        'Grzegorzewski': methods.ifVIKOR(distance=ifs.distance.grzegorzewski_distance),
        'Hamming': methods.ifVIKOR(distance=ifs.distance.hamming_distance),
        'Luo distance': methods.ifVIKOR(distance=ifs.distance.luo_distance),
        'Normalized Euclidean': methods.ifVIKOR(distance=ifs.distance.normalized_euclidean_distance),
        'Normalized Hamming': methods.ifVIKOR(distance=ifs.distance.normalized_hamming_distance),
        'Wang Xin 1': methods.ifVIKOR(distance=ifs.distance.wang_xin_distance_1),
        'Wang Xin 2': methods.ifVIKOR(distance=ifs.distance.wang_xin_distance_2),
        'Yang Chiclana': methods.ifVIKOR(distance=ifs.distance.yang_chiclana_distance),
    }

    results = {}
    for name, function in vikor.items():
        results[name] = function(matrix, fuzzy_weights, types)

    print(tabulate([[name, *np.round(pref[0], 2)] for name, pref in results.items()],
        headers=['Method'] + [f'A{i+1}' for i in range(matrix.shape[0])]))


Correlation
-------------

Correlation coefficients are used to indicate the similarity between preferences and rankings. In the PyIFDM package, there are implemented four different methods. The example of their usage is presented below. The `pearson_coef` and `spearman_coef` are used to compare the preference values, while `weighted_spearman_coef` and `ws_rank_similarity_coef` can be used to compare rankings.

.. code-block:: python
   :linenos:

    x = np.array([0.62, 0.90, 0.53, 0.87, 0.12])
    y = np.array([0.56, 0.34, 0.54, 0.82, 0.32])

    print(f'Pearson: {corrs.pearson_coef(x, y)}')
    print(f'Spearman: {corrs.spearman_coef(x, y)}')

    x = np.array([5, 3, 1, 2, 4])
    y = np.array([4, 1, 2, 3, 5])

    print(f'Weighted Spearman: {corrs.weighted_spearman_coef(x, y)}')
    print(f'WS rank similarity: {corrs.ws_rank_similarity_coef(x, y)}')
